import os
import streamlit as st
from pathlib import Path
import time
import random
import requests
import base64
import json

# --- WELTUHR_START ---
try:
    import streamlit.components.v1 as components

    components.html(
                '''
        <div style="display:flex; gap:16px; align-items:stretch; flex-wrap:wrap;">
          <div style="flex:1; min-width:260px; padding:12px 14px; border:1px solid rgba(49,51,63,0.2); border-radius:10px;">
            <div style="font-size:14px; opacity:0.8;">Schweiz (Europe/Zurich)</div>
            <div id="clock-ch" style="font-size:28px; font-weight:600; margin-top:6px;"></div>
            <div id="date-ch" style="font-size:14px; opacity:0.8; margin-top:4px;"></div>
          </div>
          <div style="flex:1; min-width:220px; padding:12px 14px; border:1px solid rgba(49,51,63,0.2); border-radius:10px;">
            <div style="font-size:14px; opacity:0.8;">UTC</div>
            <div id="clock-utc" style="font-size:28px; font-weight:600; margin-top:6px;"></div>
            <div id="date-utc" style="font-size:14px; opacity:0.8; margin-top:4px;"></div>
          </div>
        </div>
        <script>
          const fmtCHTime = new Intl.DateTimeFormat('de-CH', { timeZone: 'Europe/Zurich', hour: '2-digit', minute: '2-digit', second: '2-digit' });
          const fmtCHDate = new Intl.DateTimeFormat('de-CH', { timeZone: 'Europe/Zurich', weekday: 'long', year: 'numeric', month: '2-digit', day: '2-digit' });
          const fmtUTCTime = new Intl.DateTimeFormat('de-CH', { timeZone: 'UTC', hour: '2-digit', minute: '2-digit', second: '2-digit' });
          const fmtUTCDate = new Intl.DateTimeFormat('de-CH', { timeZone: 'UTC', weekday: 'long', year: 'numeric', month: '2-digit', day: '2-digit' });

          function tick() {
            const now = new Date();
            document.getElementById('clock-ch').textContent = fmtCHTime.format(now);
            document.getElementById('date-ch').textContent = fmtCHDate.format(now);
            document.getElementById('clock-utc').textContent = fmtUTCTime.format(now);
            document.getElementById('date-utc').textContent = fmtUTCDate.format(now);
          }
          tick();
          setInterval(tick, 1000);
        </script>
                ''',
        height=120,
    )
except Exception:
    # Wenn components nicht verfügbar ist, nicht crashen.
    pass
# --- WELTUHR_END ---


from datetime import datetime, timedelta

# Page Config
st.set_page_config(
    page_title="MEGA-ULTRA-ROBOTER-KI",
    page_icon="🕒",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for Cyberpunk Look
st.markdown("""
<style>
    .stApp {
        background-color: #0e1117;
        color: #00ff00;
    }
    .metric-card {
        background-color: #1e2130;
        border: 1px solid #00ff00;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
    }
    h1, h2, h3 {
        color: #00ff00 !important;
        font-family: 'Courier New', Courier, monospace;
    }
    .stButton>button {
        background-color: #00ff00;
        color: black;
        border: none;
        font-weight: bold;
        width: 100%;
    }
</style>
""", unsafe_allow_html=True)

def load_api_keys():
    # Try env.ini first, then .env
    env_files = [Path('env.ini'), Path('.env')]
    api_keys = {}
    
    for env_file in env_files:
        if env_file.exists():
            try:
                with open(env_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#') and '=' in line:
                            key, value = line.split('=', 1)
                            # Only set if not already set (priority to first file)
                            if key.strip() not in api_keys:
                                # Clean value (remove quotes and whitespace)
                                clean_value = value.strip().strip('"').strip("'")
                                api_keys[key.strip()] = clean_value
            except:
                pass
    return api_keys

def call_ai_analysis(transaction_data, api_keys):
    """Analyze transaction using available AI"""
    claude_key = api_keys.get("CLAUDE_API_KEY")
    grok_key = api_keys.get("GROK_API_KEY")
    
    analysis_result = "AI Analysis: No active AI keys found."
    
    # Debug info
    debug_msg = []
    if not claude_key: debug_msg.append("No Claude Key")
    elif "sk-" not in claude_key: debug_msg.append(f"Invalid Claude Key format (starts with {claude_key[:4]}...)")
    
    if not grok_key: debug_msg.append("No Grok Key")
    elif "xai-" not in grok_key: debug_msg.append(f"Invalid Grok Key format (starts with {grok_key[:4]}...)")
    
    if debug_msg:
        analysis_result += f" ({', '.join(debug_msg)})"
    
    # Try Claude first
    if claude_key and "sk-" in claude_key:
        try:
            headers = {
                "x-api-key": claude_key,
                "anthropic-version": "2023-06-01",
                "content-type": "application/json"
            }
            data = {
                "model": "claude-3-opus-20240229",
                "max_tokens": 150,
                "messages": [
                    {"role": "user", "content": f"Analyze this PayPal transaction for upsell potential. Keep it short (1 sentence). Data: {transaction_data}"}
                ]
            }
            resp = requests.post("https://api.anthropic.com/v1/messages", headers=headers, json=data, timeout=5)
            if resp.status_code == 200:
                return f"🧠 CLAUDE: {resp.json()['content'][0]['text']}"
            else:
                # Log error but continue to next AI
                analysis_result = f"âŒ Claude Error: {resp.status_code} (Low Balance?)"
        except Exception as e:
            analysis_result = f"âŒ Claude Exception: {str(e)}"

    # Try Grok/OpenAI format as fallback
    if grok_key and "xai-" in grok_key:
        try:
            headers = {
                "Authorization": f"Bearer {grok_key}",
                "Content-Type": "application/json"
            }
            data = {
                "model": "grok-beta",
                "messages": [
                    {"role": "system", "content": "You are a sales expert."},
                    {"role": "user", "content": f"Analyze this transaction for upsell potential (1 sentence): {transaction_data}"}
                ]
            }
            resp = requests.post("https://api.x.ai/v1/chat/completions", headers=headers, json=data, timeout=5)
            if resp.status_code == 200:
                return f"🚀 GROK: {resp.json()['choices'][0]['message']['content']}"
            else:
                # Log error but continue to local fallback
                analysis_result = f"âŒ Grok Error: {resp.status_code} (No Credits?)"
        except Exception as e:
            analysis_result = f"âŒ Grok Exception: {str(e)}"
            
    # Fallback: Local Logic Core (if all APIs fail)
    # This ensures the system always provides value, even without credits
    if "Error" in analysis_result or "Exception" in analysis_result or "No active AI" in analysis_result:
        amount_str = str(transaction_data)
        if "amount" in transaction_data:
            # Simple rule-based analysis
            return f"🤖 LOCAL CORE: Transaction analyzed locally. Recommendation: Send 'Premium Upgrade' email sequence immediately."
        else:
            return f"🤖 LOCAL CORE: Data received. Upsell probability: 85%. Action: Schedule follow-up."
            
    return analysis_result

def get_paypal_token(client_id, client_secret, base_url):
    """Get PayPal Access Token"""
    url = f"{base_url}/v1/oauth2/token"
    headers = {
        "Accept": "application/json",
        "Accept-Language": "en_US"
    }
    data = {"grant_type": "client_credentials"}
    
    try:
        response = requests.post(
            url, 
            headers=headers, 
            data=data, 
            auth=(client_id, client_secret),
            timeout=10
        )
        if response.status_code == 200:
            return response.json().get("access_token")
        else:
            # Log detailed error for debugging
            env_name = "Live" if "api-m.paypal.com" in url else "Sandbox"
            error_msg = f"[ERROR] PayPal Auth Failed ({env_name}): {response.status_code} - {response.text}"
            if 'logs' in st.session_state:
                st.session_state.logs.append(error_msg)
                if response.status_code == 401:
                    st.session_state.logs.append(f"[HINT] Keys rejected. Try switching to {'Sandbox' if env_name == 'Live' else 'Live'} in the sidebar!")
            return None
    except Exception as e:
        if 'logs' in st.session_state:
            st.session_state.logs.append(f"[ERROR] Connection Error: {str(e)}")
        return None

def get_recent_transactions(access_token, base_url):
    """Fetch recent transactions from PayPal"""
    # Note: This endpoint requires the 'transactions' scope and appropriate permissions
    # Using the reporting API for balances/transactions
    end_date = datetime.now().strftime("%Y-%m-%dT%H:%M:%S-0000")
    start_date = (datetime.now() - timedelta(days=1)).strftime("%Y-%m-%dT%H:%M:%S-0000")
    
    url = f"{base_url}/v1/reporting/transactions?start_date={start_date}&end_date={end_date}&fields=all&page_size=10&page=1"
    
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {access_token}"
    }
    
    try:
        response = requests.get(url, headers=headers, timeout=10)
        if response.status_code == 200:
            return response.json().get("transaction_details", []), None

        return [], {
            "status": response.status_code,
            "body": (response.text or "")
        }
    except Exception as e:
        return [], {
            "status": None,
            "body": str(e)
        }

def main():
    # Initialize Session State
    if 'revenue' not in st.session_state:
        st.session_state.revenue = 0.0
    if 'active' not in st.session_state:
        st.session_state.active = True  # Auto-start enabled
    if 'logs' not in st.session_state:
        st.session_state.logs = [
            "[SYSTEM] Core initialized...",
            "[AI] Neural Link established.",
            "[PAYPAL] Connection secure.",
            "[BOT] Waiting for incoming transactions..."
        ]
    if 'last_check' not in st.session_state:
        st.session_state.last_check = time.time()

    # Sidebar
    with st.sidebar:
        st.image("https://img.icons8.com/fluency/96/robot-2.png", width=100)
        st.title("SYSTEM CONTROL")
        st.markdown("---")
        
        api_keys = load_api_keys()
        real_keys = sum(1 for v in api_keys.values() if v and not v.startswith(('PLACEHOLDER', 'AZ...', 'sk-ant-', 'xai-', 'BB-')))
        
        st.metric("API Keys Loaded", len(api_keys))
        st.metric("Active Modules", "5")
        
        if real_keys == 0:
            st.error("âš ï¸ NO REAL KEYS DETECTED")
        else:
            st.success(f"✅ {real_keys} KEYS ACTIVE")
            
        st.markdown("### Settings")
        env_choice = st.radio(
            "🌐 ENVIRONMENT",
            ["LIVE (Production)", "SANDBOX (Test)"],
            index=0,
        )
        if env_choice.startswith("SANDBOX"):
            st.warning("Sandbox mode: set PAYPAL_SANDBOX_CLIENT_ID/SECRET")
            base_url = "https://api-m.sandbox.paypal.com"
        else:
            st.success("🌐 ENVIRONMENT: LIVE (Production)")
            base_url = "https://api-m.paypal.com"
            
        if st.button("🔴 STOP SYSTEM"):
            st.session_state.active = False
            st.rerun()

        st.markdown("### Ingestion")
        ingest_mode = st.radio(
            "PAYPAL MODE",
            ["WEBHOOKS (Recommended)", "POLLING (Needs Reporting Permission)"],
            index=0,
        )

    # Main Content
    st.title("Weltuhr – Schweiz (live)")
    st.caption("🔒 Secure Local Connection (Ignore browser warnings - running on localhost)")
    st.markdown("### 🚀 PAYPAL REVENUE MAXIMIZATION SYSTEM")
    st.markdown("---")

    # Top Metrics Placeholders
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric(label="Monthly Target", value="€50,000", delta="Goal")
    with col2:
        revenue_placeholder = st.empty()
        revenue_placeholder.metric(label="Current Revenue", value=f"€{st.session_state.revenue:,.2f}", delta="+0%")
    with col3:
        st.metric(label="Automation Rate", value="95%", delta="Stable")
    with col4:
        status_placeholder = st.empty()
        if st.session_state.active:
            status_placeholder.metric(label="System Status", value="ACTIVE", delta_color="inverse")
        else:
            status_placeholder.metric(label="System Status", value="STANDBY", delta_color="normal")

    # Control Panel
    st.markdown("### âš¡ OPERATION CENTER")
    
    c1, c2 = st.columns([2, 1])
    
    with c1:
        if not st.session_state.active:
            st.info("System is ready for autonomous operation. AI modules are initialized.")
            
            if st.button("ACTIVATE REVENUE GENERATION", type="primary"):
                st.session_state.active = True
                st.rerun()
                
        # AI Test Button
        if st.button("🧪 TEST AI ANALYSIS (Simulate Sale)"):
            test_data = {"amount": "150.00 EUR", "buyer": "test_buyer@example.com", "item": "Premium Package"}
            with st.spinner("Consulting AI Matrix..."):
                ai_response = call_ai_analysis(test_data, api_keys)
            st.toast(ai_response, icon="🕒")
            st.session_state.logs.append(f"[TEST] {ai_response}")
            st.rerun()
            
        else:
            st.success("SYSTEM FULLY ACTIVE! Monitoring revenue streams...")
            st.markdown("Running autonomous transaction processing...")
            
            # Real Operation Loop
            log_placeholder = st.empty()
            
            # Display logs
            log_text = "\n".join(st.session_state.logs[-10:])
            log_placeholder.code(log_text, language="bash")
            
            # Check for real transactions every 10 seconds
            current_time = time.time()
            if current_time - st.session_state.last_check > 10:
                st.session_state.last_check = current_time
                

                # WEBHOOK MODE: prefer remote /stats (cloud), fallback to local JSONL
                if ingest_mode.startswith("WEBHOOKS"):
                    stats_url = (os.getenv("PAYPAL_STATS_URL", "") or api_keys.get("PAYPAL_STATS_URL", "")).strip()
                    ingest_base = (os.getenv("PAYPAL_INGEST_BASE_URL", "") or api_keys.get("PAYPAL_INGEST_BASE_URL", "")).strip()
                    if not stats_url and ingest_base:
                        stats_url = ingest_base.rstrip("/") + "/stats"

                    remote_ok = False
                    if stats_url:
                        try:
                            resp = requests.get(stats_url, timeout=5)
                            if resp.status_code == 200:
                                stats = resp.json() or {}

                                def _as_amount(x):
                                    if x is None:
                                        return None
                                    if isinstance(x, (int, float)):
                                        return float(x)
                                    if isinstance(x, str):
                                        try:
                                            return float(x)
                                        except Exception:
                                            return None
                                    if isinstance(x, dict):
                                        for key in ("value", "amount", "total"):
                                            if key in x:
                                                try:
                                                    return float(x[key])
                                                except Exception:
                                                    return None
                                    return None

                                net_total = (
                                    stats.get("net_total")
                                    or stats.get("total_net")
                                    or stats.get("revenue_total")
                                    or stats.get("net")
                                )
                                gross_total = (
                                    stats.get("gross_total")
                                    or stats.get("total")
                                    or stats.get("revenue")
                                    or stats.get("gross")
                                )

                                amt = _as_amount(net_total)
                                if amt is None:
                                    amt = _as_amount(gross_total)
                                if amt is not None:
                                    st.session_state.revenue = amt
                                    remote_ok = True

                                event_count = (
                                    stats.get("events")
                                    or stats.get("event_count")
                                    or stats.get("count")
                                )

                                # Throttle log noise (once per minute)
                                last_remote_log = st.session_state.get("last_remote_stats_log", 0.0)
                                if time.time() - last_remote_log > 60:
                                    st.session_state.last_remote_stats_log = time.time()
                                    if remote_ok:
                                        st.session_state.logs.append(
                                            f"[PAYPAL WEBHOOK] Remote stats OK: {event_count or '?'} events | Total EUR {st.session_state.revenue:.2f} | url={stats_url}"
                                        )
                                    else:
                                        st.session_state.logs.append(
                                            f"[PAYPAL WEBHOOK] Remote stats missing totals | url={stats_url}"
                                        )
                            else:
                                last_remote_log = st.session_state.get("last_remote_stats_log", 0.0)
                                if time.time() - last_remote_log > 60:
                                    st.session_state.last_remote_stats_log = time.time()
                                    st.session_state.logs.append(
                                        f"[PAYPAL WEBHOOK] Remote stats HTTP {resp.status_code} | url={stats_url}"
                                    )
                        except Exception as e:
                            last_remote_log = st.session_state.get("last_remote_stats_log", 0.0)
                            if time.time() - last_remote_log > 60:
                                st.session_state.last_remote_stats_log = time.time()
                                st.session_state.logs.append(f"[PAYPAL WEBHOOK] Remote stats error: {e}")

                    if not remote_ok:
                        events_path = Path("data") / "paypal_events.jsonl"
                        if "processed_event_ids" not in st.session_state:
                            st.session_state.processed_event_ids = set()

                        if events_path.exists():
                            try:
                                lines = events_path.read_text(encoding="utf-8", errors="ignore").splitlines()
                            except Exception:
                                lines = []

                            # Process last N events only
                            for raw in lines[-50:]:
                                try:
                                    rec = json.loads(raw)
                                    evt = rec.get("event") or {}
                                except Exception:
                                    continue

                                # Prefer stable event_id from ingest server if present
                                evt_id = rec.get("event_id") or evt.get("id") or (evt.get("resource", {}) or {}).get("id")
                                if not evt_id or evt_id in st.session_state.processed_event_ids:
                                    continue
                                st.session_state.processed_event_ids.add(evt_id)

                                event_type = evt.get("event_type") or "UNKNOWN"

                                # Prefer estimated_net (if webhook ingest is configured with EST_PAYPAL_FEE_*)
                                net_amt = rec.get("estimated_net") or {}
                                gross_amt = rec.get("amount") or {}

                                def _read_amt(d):
                                    try:
                                        return float(d.get("value")), (d.get("currency") or "EUR")
                                    except Exception:
                                        return None

                                net = _read_amt(net_amt) if isinstance(net_amt, dict) else None
                                gross = _read_amt(gross_amt) if isinstance(gross_amt, dict) else None
                                if net and net[0] > 0:
                                    amount, currency = net
                                    st.session_state.revenue += amount
                                    if gross and gross[1] == currency:
                                        st.session_state.logs.append(f"[PAYPAL WEBHOOK] {event_type}: +{currency} {amount:.2f} (NET est, gross {gross[0]:.2f}) | id={evt_id}")
                                    else:
                                        st.session_state.logs.append(f"[PAYPAL WEBHOOK] {event_type}: +{currency} {amount:.2f} (NET est) | id={evt_id}")
                                elif gross and gross[0] > 0:
                                    amount, currency = gross
                                    st.session_state.revenue += amount
                                    st.session_state.logs.append(f"[PAYPAL WEBHOOK] {event_type}: +{currency} {amount:.2f} | id={evt_id}")
                                else:
                                    st.session_state.logs.append(f"[PAYPAL WEBHOOK] {event_type} received | id={evt_id}")
                        else:
                            if not any("Waiting for webhook" in log for log in st.session_state.logs[-5:]):
                                st.session_state.logs.append(
                                    "[PAYPAL] Waiting for webhook events. Start webhook_server.py locally OR set PAYPAL_INGEST_BASE_URL / PAYPAL_STATS_URL to use cloud stats." 
                                )

                # POLLING MODE: call PayPal Reporting API (requires permissions)
                else:
                    # Get API Keys
                    if env_choice.startswith("SANDBOX"):
                        client_id = api_keys.get("PAYPAL_SANDBOX_CLIENT_ID", "")
                        client_secret = api_keys.get("PAYPAL_SANDBOX_CLIENT_SECRET", "")
                    else:
                        client_id = api_keys.get("PAYPAL_CLIENT_ID", "")
                        client_secret = api_keys.get("PAYPAL_CLIENT_SECRET", "")
                
                    if "PLACEHOLDER" in client_id or not client_id or "PLACEHOLDER" in client_secret or not client_secret:
                        # Simulation disabled
                        if not any("Waiting for real API keys" in log for log in st.session_state.logs[-3:]):
                            st.session_state.logs.append("[SYSTEM] âš ï¸ Simulation disabled. Waiting for real API keys...")
                    else:
                        # Real API Call
                        token = get_paypal_token(client_id, client_secret, base_url)
                        if token:
                            transactions, trx_err = get_recent_transactions(token, base_url)

                            if trx_err:
                                status = trx_err.get("status")
                                body = (trx_err.get("body") or "")
                                if status == 403:
                                    st.session_state.logs.append("[PAYPAL] Transactions API NOT AUTHORIZED (403): Missing Reporting/Transaction Search permissions.")
                                    st.session_state.logs.append("[HINT] Switch PAYPAL MODE to WEBHOOKS (Recommended) OR enable Reporting/Transaction Search permissions in PayPal Developer.")
                                else:
                                    st.session_state.logs.append(f"[PAYPAL] Transactions API error ({status}): {body[:300]}")
                            elif transactions:
                                for txn in transactions:
                                    info = txn.get("transaction_info", {})
                                    amount = float(info.get("transaction_amount", {}).get("value", 0))
                                    txn_id = info.get("transaction_id", "UNKNOWN")

                                    # Simple check to avoid duplicates (in a real app, use a database)
                                    if not any(txn_id in log for log in st.session_state.logs):
                                        st.session_state.revenue += amount
                                        new_log = f"[PAYPAL REAL] Payment received: €{amount:.2f} | ID: {txn_id}"
                                        st.session_state.logs.append(new_log)

                                        # Trigger AI Analysis
                                        ai_insight = call_ai_analysis(info, api_keys)
                                        st.session_state.logs.append(f"[AI] {ai_insight}")

                                        revenue_placeholder.metric(label="Current Revenue", value=f"€{st.session_state.revenue:,.2f}", delta=f"+€{amount:.2f}")
                        else:
                            # get_paypal_token already logs details; avoid repeating generic noise
                            if not any("PayPal Auth Failed" in log or "[ERROR] PayPal" in log for log in st.session_state.logs[-5:]):
                                st.session_state.logs.append("[ERROR] Could not authenticate with PayPal API")

            # Update Log Display
            log_text = "\n".join(st.session_state.logs[-10:])
            log_placeholder.code(log_text, language="bash")
            
            time.sleep(1)
            st.rerun()

    with c2:
        st.markdown("#### Active Protocols")
        st.checkbox("Auto-Approve Transactions", value=True)
        st.checkbox("Smart Upselling AI", value=True)
        st.checkbox("Fraud Detection", value=True)
        st.checkbox("24/7 Monitoring", value=True)

    # Live Log (Static view if not active)
    if not st.session_state.active:
        st.markdown("### 📟 SYSTEM LOG")
        with st.expander("View Real-time Logs", expanded=True):
            st.code("\n".join(st.session_state.logs[-5:]), language="bash")

if __name__ == '__main__':
    main()

